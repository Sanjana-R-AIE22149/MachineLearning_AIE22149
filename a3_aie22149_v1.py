# -*- coding: utf-8 -*-
"""A3_AIE22149_V1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MBsKAEICORcDShukWtsG4iHWhrDmEGCv
"""

import pandas as pd
import numpy as np
import numpy.linalg as nl
import statistics
import seaborn
import  math

def Purchase_Data_Q1():
  #Reading the excel file of purchase data and storing it as a dataframe.
  df=pd.DataFrame(pd.read_excel("Lab Session1 Data.xlsx"))
  df.dropna(axis=1,inplace=True) #Dropping the empty columns and rows
  matrix=df.values #Converting the dataframe values into an array.
  return matrix

def segregate_A_C(matrix):
  a=[]
  for i in range(len(matrix)):
    for j in range(1,4):
      a.append(matrix[i][j])
  A=np.array(a)
  A=A.reshape(10,3)  #Matrix A
  C=np.array([])
  for i in range(len(matrix)):
     C=np.append(C,matrix[i][-2]) #Matrix C
  return (A,C)

def dimensionality(input_matrix):
  #Returns the dimensionality of the vector space of given matrix/vector.
  return input_matrix.ndim

def number_of_vectors(vector_input):
  #Returns the number of vectors existing in the vector space.
  return vector_input.size

def rank_of_matrix(input_matrix):
  #Returns the rank of given matrix.
  return np.linalg.matrix_rank(input_matrix)

def pseudoinverse(input_matrix):
  #Returns the pseudoinverse of matrix.
  return np.linalg.pinv(input_matrix)

def dot_pdt(mat_a,mat_b):
  #Returns the dot product of two matrices.
  return np.dot(mat_a,mat_b)

def mean_and_variance(df):
  #Finds the mean and variance of price column of given dataframe.
  prices=df.loc[:,"Price"] #Column D-Prices
  mean_of_prices=statistics.mean(prices) #mean of the prices column
  variance_of_prices=statistics.variance(prices) #Variance of the prices column

  return (mean_of_prices,variance_of_prices)

def wednesday_prices_mean(df):
  wednesday_prices=df.loc[df["Day"]=="Wed","Price"]
  sample_mean_wednesday=statistics.mean(wednesday_prices) #Sample mean of prices from wednesday
  return sample_mean_wednesday

def april_mean_prices(df):
  april_prices=df.loc[df["Month"]=="Apr","Price"]
  sample_mean_april=statistics.mean(april_prices)
  return sample_mean_april

def loss_probability(df):
  negative_index=df["Chg%"].apply(lambda x:x<0) #Denotes if the Chg% is negative or not
  negative_Chg=df[negative_index]["Chg%"] #Retreiving the negative Chg% values based on negative_index
  count_negativeChg=negative_Chg.size #Number of entries with negative Chg%
  total_count_Chg=df["Chg%"].size #Total number of entries in Chg%
  probability_of_loss=count_negativeChg/total_count_Chg #probability of negative Chg% (Loss)

  return(probability_of_loss)

def wed_profit(df):
  positive_index=df["Chg%"].apply(lambda x:x>0) #Denotes if he Chg% is positive or not
  positive_Chg_wednesday=df.loc[(df["Day"]=="Wed")& ( df["Chg%"]>0),"Chg%"] #Entries where Chg% is positive and day is wednesday
  count_positive=positive_Chg_wednesday.size #Number of entries with profit on wednesday
  total_count=df["Chg%"].size
  probability_of_wednesday_profits=count_positive/total_count

  return (probability_of_wednesday_profits)

def conditional_probability(df):
   #Finding the probability of Wednesday
   count_of_wednesdays=df.loc[df["Day"]=="Wed","Day"].size
   count_of_days=df["Day"].size
   wednesdays_probability=count_of_wednesdays/count_of_days
   #Conditional probability of profit given it is a wednesday
   probability_of_wednesday_profits=wed_profit(df)
   conditional_probability_profit_Wed=(probability_of_wednesday_profits)/(wednesdays_probability)

   return (conditional_probability_profit_Wed)

def give_plot(df):
  #Scatter plot of Chg% against Days of week
  col_x=df["Day"]
  col_y=df["Chg%"]
  seaborn.scatterplot(x=col_x,y=col_y,data=df)

def distance(vec_1,vec_2):
  #Calculates the euclidean distance between the 2 vectors.
  sum=0 #Sum of squares of all differences
  for i in range(len(vec_1)):
      sum+=math.sqrt((vec_2[i]-vec_1[i])**2)
  return sum

def rich_or_poor(input_vector,k):
  #Classify if a customer is rich or poor based on their purchasing habit. Based on Knn classifier i wrote in lab 2
  df=pd.DataFrame(pd.read_excel("Lab Session1 Data.xlsx"))
  classes={"Rich":0,"Poor":0}
  vectors=df.iloc[:,1:5]
  vector_comparison=[]
  for vector in vectors.values:
    vector_comparison.append(vector)
  distances=[]
  for i in vector_comparison:
    distance_current=distance(i,input_vector)
    distances.append(distance_current)

  distance_dict={index:distances[index] for index in range(len(distances))}
  top_matches_k={}

  sorted_dist=dict(sorted(distance_dict.items()),key=lambda item:item[1])
  matches=[]

  indices_sorted=list(sorted_dist.keys())

  for i in range(k):
    index=indices_sorted[i]
    label=df.iloc[index,-1]
    matches.append((index,sorted_dist[index],label))

  for i,j,label in matches:
    if label=="Rich":
      classes["Rich"]+=1
    elif label=="Poor":
      classes["Poor"]+=1

  class_final=max(classes,key=classes.get)

  return (class_final)

def main():
 op=int(input('''Enter the option:
	          1.  Purchase Data
	          2. Model Vector for predicting cost of the products
	          3. Rich-Poor Classifier
	          4. IRCTC Stock Price
	       '''))
 if op==1:
  data_matrix=Purchase_Data_Q1()
  (A,C)=segregate_A_C(data_matrix)
  print(f"Matrix A: {A}")
  print(f"Matrix C:{C}")
  dimensionality_A=dimensionality(A)
  print(f"Dimensionality of the vector space of A is {dimensionality_A}.")
  number_of_vectors_in_vecspace=number_of_vectors(C) #Number of vectors is equal to size of C (number of entries)
  print(f"Number of vectors in the vector space is {number_of_vectors_in_vecspace}.")
  rank=rank_of_matrix(A) #Rank of matrix A
  print(f"Rank of the matrix A is {rank}.")
  pseudoinverse_A=pseudoinverse(A) #Pseudoinverse of A
  print(f"Pseudoinverse of matrix A is {pseudoinverse_A}.")
  cost=dot_pdt(pseudoinverse_A,C)
  print(f"Cost of each product is {cost}.")

 elif op==2:
  matrix=Purchase_Data_Q1()
  (A,C)=segregate_A_C(matrix)
  model_vector=pseudoinverse(A) #Model vector to find cost
  print(f"The model vector to calculate the cost is {model_vector}.")

 elif op==3:
   list_string=input("Enter the vector separated by commas: ")
   input_vector=[int(x) for x in list_string.split(',')]
   predicted_class=rich_or_poor(input_vector,3)
   print(f"The person is {predicted_class}.")

 elif op==4:
  #Read the IRCTC Stock Price sheet of the Data excel workbook.
  df2=pd.DataFrame(pd.read_excel("Lab Session1 Data.xlsx",sheet_name="IRCTC Stock Price"))
  (mean,variance)=mean_and_variance(df2)
  print(f"Mean of the Prices column is {mean}. Variance of the Prices column is {variance}.")

  wednesday_sample_mean=wednesday_prices_mean(df2)
  print(f"Sample mean of prices on wednesdays is {wednesday_sample_mean}.")
  #The sample mean of wednesdays prices and population mean differ by approximately 10.
  #The prices on wednesday are approximately 10 more than average.
  april_sample_mean=april_mean_prices(df2)
  print(f"Sample mean of prices in april is {april_sample_mean}.")
  #The prices in april is almost 139 higher than average.
  loss=loss_probability(df2)
  print(f"Probability of making a loss is {loss}. ")

  w_profit=wed_profit(df2)
  print(f"Probability of making a profit on wednesday is {w_profit}.")

  c_probability=conditional_probability(df2)
  print(f"The probability that we will get a profit given that it is a wednesday is {c_probability}.")

  give_plot(df2)



 else:
  print("Enter a valid option!")


main()